# 嵌入式八股文
## c++基础知识
### 指针与引用
区别：  
是否分配存储空间：指针本身就是一个变量，因此会分配存储空间,但是引用只是变量的别名，不会分配额外的存储空间  
是否需要初始化对象：指针可以初始化为NULL；而引用必须初始化为确定的目标。  
### c++三大特性
#### 1:继承，封装，多态。
继承|封装|多态
-|-|-
使派生类可以使用现有类的所有功能|将数据及代码完全捆绑在一起，避免外界干扰和不确定性访问|同一事物表现出不同事物的能力，<font color=#0099ff>*重载实现编译多态，虚函数实现运行多态*</font>      
#### <font color=#0099>2.类的成员属性</font>: 
public|protected|private
-|-|-
类内类外均可通过对象访问|类内可以互相访问，类外无法通过对象访问|类内可以互相访问，类外无法通过对象访问  
#### 2.1.多态的两种实现方法：override（重写）和overload（重载）
重写|重载
-|-
子类重新定义父类<font color=#0099ff>虚函数</font>|指允许存在多个同名函数，而这些函数参数表不同
#### <font color=#0099ff>3：虚函数</font>：由两部分构成，<font color=#00ffff>虚函数指针与虚函数表</font>。其中虚函数指针是一个指向虚函数的指针，与一般指针相同。每一个类都有一张虚函数表，用来存放虚函数指针。<font color=#00FF>虚函数指针一般放在对象的地址首部。</font>   
<font color=#ff0000> 3.1：虚函数特点：</font>  
序号|特点
-|-
1|虚函数的绑定发生在运行期
2|内联函数，静态函数，构造函数不可以是虚函数  
#### 4：抽象类与接口的实现：  
4.1抽象类：类中至少有一个函数被声明为纯虚函数的类。<font color=#0000ff>抽象类不能用于实例化对象，只能作为接口使用。</font>  
4.2纯虚函数：无定义的虚函数，通过使用“=0”来进行指定。   
```c++
printf("写一段代码");
```  
#### 5：智能指针：是一个类，可以在对象超出作用域后，自动调用类的析构函数释放资源。主要包括四种智能指针:unique_ptr（独占式指针，同一时刻只能有一个指针指向同一个对象）；shared_ptr（共享式指针，同一时刻可以有多个指针指向同一个对象）；weak_ptr（用来解决shared_ptr相互引用导致的死锁问题）；auto_ptr。
##### 5.1智能指针之间的区别：
shared_ptr|unique_ptr
-|-
shared_ptr<font color=#ff0000>支持赋值，复制和移动</font>|不支持复制，赋值但是<font color=#ff0000>支持移动</font>
<font color=#ff0000>内存占用为裸指针的两倍</font>，因为除了要管理一个裸指针外，还要维护一个引用计数|与裸指针大小一致。
##### 5.2：shared_ptr的线程安全问题：<font color=#ff0000>同一个shared_ptr被多个线程”读“是安全的，但是被多个线程写是不安全的，共享引用计数的不同shared_ptr被多个线程写是安全的</font>
#### 6：强制类型转换：static_cast,dynamic_cast,const_cast和reinterpret_cast。用来实现不同数据类型之间的转换。
 NULL|static_cast|dynamic_cast|const_cast|reinterpret_cast
 -|-|-|-|-
运行时是否检查保证转换的安全性|否|是|/|/
转换数据类型|用于基本类型转换，可以把任何类型的表达式转化为void|<font color=#ff0000>本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常</font>|去除对象的const或volatile属性，<font color=#ff0000>将常量指针转换为非常量指针，并仍指向原来的对象；将常量引用转换为非常量引用</font>|可以实现任意类型之间的转换
#### 6：内存泄漏：由于错误或疏忽导致<font color=#ff0000>程序未能释放掉不再使用的内存的情况</font>，最终使该部分内存失去控制。
##### 6.1：内存泄漏的分类
* 堆内存泄漏：通过malloc或new分配的内存在使用完成之后没有用free或delete释放掉  
* 系统资源泄漏：程序使用系统分配的资源没有用相对应的函数释放掉。  
* 没有将基类的析构函数定义为虚函数：当基类指针指向派生类对象时，若基类析构函数不是虚函数，那么子类的析构函数将不会被调用。
### 注：<font color=#ff0000>函数的形参是一个地址，数组的大小无效。</font>

## 计算机基础
### 操作系统
#### 1：定义：介于硬件资源与应用程序之间的一个系统软件
#### 2：功能：  
* 资源分配及回收，所控制的资源主要包括CPU，内存，外存，IO设备。
* 为应用程序提供服务，将硬件资源的操作进行封装，提供相对同一的接口供开发者调用。
* 管理应用程序，即控制进程的生命周期，包括进程开始时的环境配置和资源分配，进程结束后的资源回收
* 操作系统内核（指一个提供硬件抽象层，磁盘及文件系统控制，多任务等功能的系统软件）的功能：进程管理能力，内存管理能力，硬件通信能力（网络），系统调用能力（接口调用）
#### 3：进程：<font color=#00ffff>是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位.</font>
##### 3.1：进程的组成：主要包括<font color=#00ffff>进程控制块(PCB)</font>，<font color=#7fff00>数据段</font>，<font color=#ff0000>程序段</font>。其中<font color=#00ffff>进程控制块（PCB）</font>主要包括，进程描述信息，进程控制和管理信息，资源分配清单以及CPU相关信息。
* 进程描述信息：当进程被创建时，操作系统会为其分配一个唯一的，不重复的”身份证号“——<font color=#7fff00>PID</font>,同时还会分配一个进程所属的用户ID——<font color=#ff0000>UID</font>
* 进程控制和管理信息（时间）：记录进程的运行状态，CPU的使用时间，磁盘使用情况，网络流量使用情况，记录进程的优先级等信息。
* 资源分配清单（空间）：记录给进程分配了哪些资源。如分配了多少内存，有多少IO设备正在被使用，正在使用哪些文件。
* CPU相关信息：进程在让出CPU时，必须保存该进程在CPU中的各种信息，如各种寄存器的值。用于实现进程切换，确保这个进程再次运行的时候回复CPU现场，从断电处继续执行。这也被称作<font color=#7fff00>保存现场信息</font>
##### 3.2：进程的状态：尽管每一个进程都是一个独立的实体，有其自己的PCB和内部状态，但是进程之间经常需要相互作用。一个进程的输出可能是另一个进程的输入，因此会造成进程可能会由于缺少必要的条件而退出运行。经典进程状态被分为三态：<font color=#ff0000>运行态，就绪态，阻塞态。</font><font color=#7fff00>进程三态之间的转换如下:</font>
![三态转换](https://pic1.zhimg.com/v2-b4f5eab75ddde6b17ec192a9a78b7d44_r.jpg)

CPU通过PCB来管理不同状态的进程，其一般会将处于同一状态的所有进程的PCB链接在一起，这种数据结构被称为<font color=#00ffff>进程队列。</font>
#### 3.3：进程控制：对系统中的所有进程进行有效的管理，<font color=#ff0000>实现进程状态转换</font>功能。包括<font color=#00ffff>进程创建，阻塞进程，唤醒进程，终止进程</font>，这些功能均由<font color=#7fff00>原语</font>来实现。原语指具有原子性的程序，即其在执行时不可中断。  

![操作系统](https://pic3.zhimg.com/v2-99f342977f13c14d5fd7fcb459c0e31a_r.jpg)

##### 3.3.1：进程创建：操作系统在初始启动时会创建<font color=#00ffff>一些承担系统资源分配和控制管理的系统进程，同时还会创建一个所有用户进程的祖先</font>，其它用户进程是在应用程序运行时创建的。操作系统<font color=#ff0000>允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止后，其在父进程处继承的资源应当还给父进程。同时，终止父进程也会同时终止其所有的子进程。</font>
<font size=5>创建进程的过程（创建原语）：</font>  
* 在<font color=#ff0000>进程列表</font>中新增一项，并从PCB池中申请一个空闲的PCB（PCB有限，若申请失败则创建失败），为新进程分配一个唯一的进程标识符。
* 为进程分配地址空间，由<font color=#ff0000>进程管理程序</font>确定加载至进程地址空间的程序及数据。
* 为进程分配各种资源。
* 初始化PCB，如进程标识符，CPU初始状态等。
* 将新进程的状态设为就绪态，并将其移入<font color=#ff0000>就绪队列</font>，等待被调度运行。

##### 3.3.2：进程终止：进程的终止也被称为撤销，进程完成特定工作或出现严重错误后必须被终止。引起进程终止的事件有三种即：<font color=#00ffff>正常结束：进程自己请求终止；异常结束：进程出现严重错误，操作系统强行终止；外界干预：ctrl+alt+delete打开进程管理器，用户手动杀死进程。</font>
<font size=5>终止进程的过程（撤销原语）：</font>  
* 从<font color=#ff0000>PCB集合</font>中找到终止进程的PCB；
* 若进程处于运行态，立即剥夺其CPU，终止该进程的执行，然后将CPU资源分配给其它进程。
* 若其还有子进程，则应将其所有子进程终止
* 将该进程所有资源还给父进程或操作系统
* 回收PCB并将其归还至PCB池

##### 3.3.3：进程的阻塞及唤醒：进程阻塞指进程让出CPU资源转而等待一个事件，如等待资源，IO设备等。进程常使用阻塞原语来阻塞自己，所以<font color=#ff0000>阻塞是进程的自主行为，是一个同步事件。当等待事件完成时，会产生一个中断，激活操作系统</font>，在系统的控制下将被阻塞的进程激活，即唤醒原语。
<font size=5>阻塞进程的过程（阻塞原语）：</font>  
* 找到将要被阻塞的进程PCB。
* 保护进程运行现场（CPU寄存器的值），将PCB状态信息设为阻塞态。暂停进程运行。
* 将该PCB插入相应事件的阻塞队列（等待队列）。

<font size=5>唤醒进程的过程（唤醒原语）：</font>
* 在阻塞队列中找到相应进程的PCB；
* 将该PCB从阻塞队列中移出，并将状态信息设置为就绪态；
* 将该PCB插入到就绪队列中，等待被调度程序调度。 

<font size=4>
阻塞原语与唤醒原语的作用相反，阻塞原语使进程从运行态转为阻塞态，而唤醒原语则将进程从阻塞态转为就绪态。如果某个进程使用阻塞原语来阻塞自己，那么就必须使用唤醒原语来唤醒自己，因何事阻塞，就由何事唤醒，否则被阻塞的进程永远处于阻塞态。<font color=#7fff00>因此阻塞原语和唤醒原语是成对出现的。</font>
</font>

##### 3.3.4：进程上下文切换：各进程之间是共享CPU资源的，一个进程不能永远占用CPU资源，不同时候进程之间需要切换，使不同的进程被分配CPU资源，这个过程就是进程的上下文切换。<font color=#00ffff>一个进程切换到另一个进程运行</font>。由于进程是由内核进行管理和调度的，所以<font color=#ff0000>进程的上下文切换一定发生在内核态。</font>
<font size=5>切换进程的过程（切换原语）：</font>  
* 首先，将进程A的运行环境存入PCB，这个运行环境就是进程的上下文；
* 然后将PCB移入相应队列；
* 选择另一个进程B进行执行，并更新其PCB的状态为运行态；
* 当进程A被恢复运行的时候，根据它的PCB回复进程A所需要的运行资源。
<font size=4 color=#00ffff>引起进程上下文切换的事件的原因有如下：</font>
* 当前进程的时间片到
* 有更高优先级的进程达到
* 当前进程主动阻塞
* 当前进程退出

#### 4：线程：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程，<font color=#ff0000>多个线程之间共享进程的资源。</font>
##### 4.1：为什么引入线程：线程又称为迷你进程，比进程更容易创建，也更容易撤销。将<font color=#00ffff>进程作为资源分配单位和调度单位两个属性分开处理</font>，即进程依然作为资源分配的基本单位，但是不作为调度的基本单位，将调度执行和切换的责任交给线程，即<font color=#00ffff>线程成为独立调度的基本单位</font>
##### 4.2：线程特征：其特征与进程相似，进程有的线程基本都有：
* 线程具有就绪，阻塞，执行三态。
* 线程间可以并发执行
* 多CPU环境下，各个线程可以被分配到不同的CPU上执行。
##### 4.3：线程优缺点：
优点：  
* 一个进程中可以存在多个线程，这些线程共享进程的资源，进程间的通信必须请求操作系统服务，开销较大。而同进程下的线程通信无需操作系统干预，开销更小。
* 线程的并发比进程的开销更小，系统并发性提升。  

缺点：当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃。

#### 5：进程调度算法：一个单核CPU同时只能运行一个线程，因此需要<font color=#00ffff>按照一定的规则来确定处理这些进/线程的顺序以实现多进程或多线程的并发执行</font>，这就是调度算法要研究的问题。
##### 5.1：调度算法常见类型：
* <font color=#00ffff>非抢占式调度算法</font>：发生时钟中断时不调度（正在执行的进程只有在该进程执行完成或发生阻塞时才会释放CPU）；
* <font color=#ff0000>抢占式调度算法</font>：通过时钟中断使CPU控制权返回给调度程序，进而调度其它进程（分给进程的时间片结束后，不论进程是否执行完成，调度程序均选择其它进程执行）。

##### 5.2：非抢占式调度算法：
* 先来先服务算法（FCFS）（按照进程请求CPU的顺序调度它们）：所有就绪状态的进程在一个队列中，申请使用CPU的进程按照先来后到的顺序排在队列尾部，每执行完一个进程，系统就从该队列的头部取出第一个进程来执行。
* 最短作业优先算法（SJF）：每次调度时选择当前已到达的，且运行时间最短的作业。
* 非抢占式优先级调度：每个进程被赋予一个优先级，<font color=#00ffff>允许优先级最高的可运行进程先运行。</font>

##### 5.3：抢占式调度算法：
* 最短剩余时间优先：当一个新的进程到达时，将其完整运行所需要的CPU时间与当前正在运行的进程的剩余时间进行对比，若小于，则挂起当前进程，运行新的进程；否则新的进程等待。（<font color=#00ffff>抢占式最短作业有限</font>）
* 轮转调度：每个进程被分配一个时间段，允许该进程在该时间段内运行。
* 抢占式优先级调度：每个进程被赋予一个优先级，允许优先级最高的可运行进程先运行；但是就绪队列中的进程的优先级是动态调整的，<font color=#00ffff>其优先级随着等待的时间而增大。</font>
* 多级反馈队列：在系统中设置多个就绪队列，<font color=#00ffff>就绪队列的优先级从第一个开始逐渐降低，同时每个队列的时间片与优先级成反比。</font>其特点如下：<font color=#7fff00>首先调度高优先级队列中的进程，当高优先级队列中的进程全部调度完成后，则进行下一个优先级队列中的进程调度。同一队列内的进程采用时间片轮转调度。最后当一个进程使用完分配的时间片后，它被移到低一级优先级队列。</font>
* 彩票调度：为进程提供各种系统资源的彩票，一旦需要进行进程调度时，就随机抽取一张彩票，拥有该彩票的进程获得该彩票对应的资源。
* 公平分享调度：考虑进程的拥有者是谁，保证每个用户公平地分享CPU

#### 6：进程调度算法时间计算：
平均等待时间：每个进程等待时间的平均值。

#### 7：进程通信：指进程之间的信息交换。<font color=#7fff00>进程的同步和互斥本质上也是一种进程通信，不过其仅传输信号量，不传输数据。</font><font color=#00ffff>由于内核空间是每个进程都共享的，所以进程之间要进行信息交换就必须通过内核。</font>
![进程通信](https://pic2.zhimg.com/80/v2-1c0a8bc38f13325491ab6a8b0f781be1_1440w.webp)
常见进程通信机制包括以下七种：
* 管道（无名管道和有名管道）
* 消息队列
* 共享内存
* 信号
* 信号量和PV操作
* 套接字（socket）

##### 7.1：无名管道：一个文件，但它不是普通的文件，不属于某个文件系统，只存在于内存中。<font color=#ff0000>管道的本质就是内核在内存中开辟了一块<font size=3>缓冲区</font>,此缓冲区与管道文件相关联，对管道文件的操作被内核转换成对这块缓冲区的操作。</font>
```
$ command 1|command 2
```
以上Linux命令就组成了一个管道，<font color=#00ffff>以命令1的输出作为命令2的输入，从功能描述可以看出管道中的数据只能单向流动，也就是半双工通信。并且通过|创建的管道是无名管道，使用完成后会自动销毁，并且只能在具有亲缘关系（父子进程）的进程间使用。</font>在实际的linux编程中，通过pipe函数创建匿名管道，若成功返回0；否则返回-1：
```
int pipe(int fd[2]);
```
此函数拥有一个存储空间为2的文件描述符数组：<font color=#00ffff>fd[0]指向管道的写端，fd[1]指向管道的读端。且fd[1]的输出是fd[0]的输入。</font>

<font size=4>匿名管道实现通信的步骤：</font>  
* 父进程创建<font color=#00ffff>两个匿名管道</font>，管道1和管道2；
* <font color=#00ffff>父进程fork出子进程，于是对于这两个匿名管道，子进程也分别有两个文件描述符指向匿名管道的读写两端；</font>
* <font color=#00ffff>父进程关闭管道1的读端fd[0]和管道2的写端fd[1]，子进程关闭管道1的写端fd[1]和管道2的读端fd[1]；<font size=4>这样管道1只能用于父进程的写和子进程的读，管道2只能用于父进程的读和子进程的写</font></font>;管道使用环形队列实现，数据从写端流入从读端流出。  
  

![匿名管道通信](https://pic3.zhimg.com/v2-9a3131e0e838332fecaab3476eda26fa_r.jpg)
---
##### 7.2：有名管道：为克服匿名管道只能用于父子进程通信的缺点，提供了一个有路径名的管道，可供无亲缘关系的管道使用以进行通信。
```
#Linux命令如下
$ mkfifo mypipe //创建有名管道
$echo "hello" >mypipe   //向有名管道中写入数据
$ cat < mypipe //读取mypipe的值
hello
```

##### 7.3：消息队列：存放在内存中的消息的链表，本质上是用户自定义的数据结构。（消息队列中的数据有一定的格式）其工作模式如下：
![消息队列](https://pic1.zhimg.com/80/v2-a2caf6e76f9407a1752a220080b10134_1440w.webp)
<font color=#00ffff>当进程A需要给进程B发送数据时，将数据放入对应消息队列后即可返回，B进程在需要的时候自行进入消息队列读取数据。同理，B进程给A进程发送消息也是同样的。</font>消息队列与管道的不同点：<font size=4>  
* 消息队列允许一个或多个进程同时进行读或写操作；
* 消息队列可以实现消息的随机查询，不一定要按照先入先出的次序读取消息，也可以按照消息的类型进行读取。
* 对于消息队列来说，在某个进程向一个队列中写入消息之前，不需要有另一个进程在该消息队列上等待消息的到达。而对于管道来说，除非读进程已经存在，否则写进程写入操作是没有意义的。
* 消息队列的生存周期随内核，如果没有释放消息队列或关闭消息队列，其一直存在。而匿名管道随进程的创建而建立，随进程的结束而销毁。</font>

消息队列对于交换较少数量的数据很有用，因为无需避免冲突，但是由于用户写入数据到内存的消息队列时会发生用户态拷贝数据到内核态的过程；同样的另一个用户进程读取内存中断消息数据时，会发生从内核态拷贝数据到用户态的过程。<font color=#00ffff>如果数据量较大，使用消息队列会造成频繁的系统调用，同样也会消耗更多的时间以使内核介入。</font>

##### 7.4：共享内存：避免像消息队列那样进行<font color=#ff0000>频繁的拷贝</font>，共享内存允许不相关的进程访问<font color=#00ffff>同一个物理地址。</font>这部分物理内存就成为共享内存。
###### <font size=4>7.4.1：共享内存的基本原理：每个进程都有属于自己的进程管理块（PCB）和逻辑地址空间（Addr Space），以及与之相对应的页表，负责将进程的逻辑地址（虚拟地址）与物理地址进行映射，通过内存管理单元进行管理。<font color=#00ffff>两个不同进程的逻辑地址通过页表映射到同一片物理内存，这块内存就是共享内存。不同于消息队列频繁进行系统调用，共享内存仅在建立共享内存区域时需要进行系统调用，一旦建立共享内存之后，所有的访问都可以作为常规内存访问，不需要借助内核。是一种最快的进程通信方式</font>工作流图如下</font>
![逻辑地址映射](https://pic4.zhimg.com/v2-30fd4ee32afadbc97fc602a8461ac74b_r.jpg)
![进程通信](https://pic2.zhimg.com/80/v2-b2f88341dfb4ed26e5e11a7408e8766d_1440w.webp)

##### 7.5：信号量和PV操作：<font color=#00ffff>共享内存虽然可以做到快速的信息传递，但是其不允许不同进程同时进行信息的读写操作，也无法控制进程进行读写操作的顺序。一个实例如下：</font>为了克服上面的问题，保证共享内存在任何时候都只有一个进程在访问(互斥)，并且使进程能够按照某个特定的顺序访问共享内存(同步)；需要使用进程的同步和互斥机制。如<font color=#00ffff>如信号量和PV操作。</font>同时需要注意的是，<font color=#00ffff>进程的同步和互斥实际上是对进程通信的保护机制，并不是用来传输进程之间通信的真正内容的，但是由于他们会传输信号量，所以也被纳入进程通信的范畴，成为低级通信。</font>
![共享内存的问题](https://pic2.zhimg.com/v2-44d3a2d42d9c6c0be7e636d192cdd749_r.jpg)

##### 7.5.1：信号量与PV操作：一个变量，用来表示系统中某种资源的数量。而PV操作就是一对用来对信号量操作的原语。
* P操作：将信号量减1，表示<font color=#00ffff>申请占用一个资源。</font>如果<font color=#ff0000>结果小于0</font>，表示已经没有可用资源，执行P操作的进行被阻塞，否则执行P操作的进程继续执行。
* V操作：将信号量加1，表示<font color=#00ffff>释放一个资源，若加完之后的信号量的值<font color=ff0000>小于等于0</font>，则说明有某些进程在等待该资源，需要唤醒一个等待使用该资源的进程（使该进程进入就绪态）。</font>

##### 7.5.2：信号量和PV操作的具体定义如下
```
//信号量定义
typedef struct semaphore{
    int value；//信号量值
    struct pcb*list；//信号量队列指针
}
//P操作
void P(semaphore s){
    s.value--;
    if(s.value<0){
        asleep(s.list);
    }
}
//V操作
void V(semaphore s){
    s.value++;
    if(s.value<=0>){
        wakeup(s.list);
    }
}
```
##### 7.5.3：互斥访问共享内存：两步走实现不同进程对共享内存的互斥访问：
* 定义一个互斥信号量，并将其值初始化为1
* 把对共享内存的访问置于P操作和V操作之间
```
semaphore mutex=1;//初始化互斥信号量
//进程P1
P1(){
    P(mutex);//申请访问共享内存
    访问共享内存；
    V(mutex);//释放共享内存
}
//进程P2
P2(){
    V(mutex);//申请访问共享内存
    访问共享内存；
    V(mutex);//释放共享内存
}
```
上面这段代码通过互斥访问，保证同一时刻只有一个进程在访问共享内存。

##### 7.5.4：进程同步：三步走实现不同进程的同步。
* 定义一个同步信号量，并初始化为当前可用资源数量；
* 在<font color=#00ffff>优先级较高的操作后面执行V操作</font>，释放资源；
* 在<font color=#00ffff>优先级较低的操作前面执行P操作</font>，申请占用资源。
```
//初始化同步信号量为0
semaphore s=0；
//定义进程1
P1(){
    code1;
    code2;
    V(s); //代码2执行完成后，释放资源。
    code 3;
}
P1(){
    P(s); //代码4运行前先申请占用资源，保证代码4在代码2后执行。
    code4;
    code5;
    code6;
}
```
上面这段代码实现代码4和代码2之间的顺序执行，保证其同步性。

##### 7.6：信号：是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。<font color=#00ffff>通过发送指定信号来通知进程某个异步事件的发生，以迫使进程执行信号处理程序。信号处理完毕后，被中断的进程将恢复执行。</font>用户，内核和进程都能生成发送信号。
##### 7.7：socket：实现跨网络不同主机的进程通信。
#### <font size=4>总结：
* 首先，最简单的通信方式就是管道。管道的本质是存放在内存中的特殊的文件，内核在内存中开辟一块缓冲区，该缓冲区与文件相关联，对文件的操作都被内核转化为对该缓冲区的操作。管道被分为匿名管道和有名管道，其中匿名管道只能用于父子进程之间的通信，而有名管道没有限制。
* 由于管道效率比较低，不适合进程间进行频繁的数据传递，并且只能传递无格式的字符流。因此又产生了消息队列。其本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，那么该消息就会从消息队列中删除。
* 由于消息队列的速度比较慢，在每次数据的写入和读取时都需要经过用户态和内核态之间的数据拷贝过程。因此产生了共享内存。其本质就是将两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这片区域就是共享内存。共享内存只有在创建的时候需要系统调用，一旦建立共享内存后，对共享内存的访问都可以看作是常规内存访问，无需借助内核。
* 但是共享内存存在访问冲突以及无法实现进程间同步运行的缺点，因此采用信号量和PV操作来解决上面两个问题。
* 信号则是进程通信机制中唯一的异步通信机制，其可以在任何时候发送信号给某个进程，来通知进程某个异步事件的发送，以迫使进程执行信号处理程序，当信号处理程序执行完成后，被中断进程将恢复执行。</font>

<font size=4>本部分基础概念  
1：应用程序从磁盘读取文件的数据过程：  
* 先将数据从【磁盘】复制到【内核buffer】；
* 在将数据从【内核buffer】复制到【用户buffer】。

2：内核：是一个操作系统的核心，是基于硬件的第一层软件扩充，提供操作系统最基本的功能，负责管理系统的进程，内存，设备驱动程序，文件和网络系统。

## <font size=7>计算机网络</font>
### <font size=6> 1.计算机网络的定义</font>：<font size=5>指借助通信线路将两台甚至多台计算机和其它硬件设备之间建立起连接，位于网络内部的计算机可以实现相互通信，相互传递数据和指令，还可以共享系统内部的硬件和软件资源。也被称为互联网</font>
### <font size=6>2.网络分类</font>：个域网，局域网，城域网，广域网。
### <font size=6>3.网络核心的两大功能：
$\qquad$<font size=5>路由：确定数据分组从源到目标所使用的路径</font>

$\qquad$<font size=5>转发：路由器或交换机将接收到的数据分组转发出去</font>

### <font size=6>4.网络分层</font>
TCP/IP 5层模型|OSI 7层模型
-|-
![](https://img-blog.csdnimg.cn/20210622193853938.png)|![](https://img-blog.csdnimg.cn/20210622193020191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTAxODY5,size_16,color_FFFFFF,t_70)

#### <font size=5>各分层的作用</font>
* <font size=4>应用层：所有和应用程序协同工作，并利用基础网络交换应用程序的协议。其包括<font color=#00ffff>http协议（文本传输协议）。</font>
* 传输层：主要功能包括：<font color=#00ffff>为端到端连接提供传输服务，并为其提供流量控制，差错控制，QoS服务质量等管理服务。</font>
* 网络层：在复杂的网络环境中为要发送的数据报找到一个合适的路径进行传输，即网络层负责把数据传输到目标地址。
* 数据链路层：处理连接网络的硬件部分，该层包括操作系统硬件的设备驱动，NIC，光纤等物理可见部分，以及连接器等一切传输媒介。
##### <font size=4>基础概念：
* MAC地址：物理地址，长度为48位
* IP地址：软件层面的地址，人为规定；长度为32位。
* Mac地址表：Mac地址与端口的映射。
* 默认网关：发送给不同子网的IP地址。
* 路由表：IP地址与端口的映射表。
* arp协议（arp缓存表）：IP与MAC地址的对应关系。</font>
* 下一跳：
##### <font size=4>数据传输过程：
电脑视角：
* 需要知道自身IP以及目标IP
* 通过掩码确定与目标是否在同一子网
* 如果在同一子网，则通过arp表确定目标mac地址通过交换机将数据发送给目标
* 如果不在同一子网，则通过arp获取默认网关的mac地址，将数据发送给路由器  

交换机视角：
* 所收到的数据必须有目标mac地址
* 通过mac地址表查找对应端口
* 查到了就按照映射关系将数据从对应端口发送出去
* 查不到就所有端口都发送出去  

路由器视角：
* 所收到的数据必须包含目标IP地址
* 根据路由表确定目标IP所对应的端口
* 查到了就按照映射关系从指定端口发送
* 查不到返回一个路由不可达的数据包  
 
整体流程：首先电脑A将目标IP与子网掩码做与运算，如果在同一子网下，则通过arp表找到目标ip对应的mac地址，将源mac与目标mac封装在数据链路层头部，发送给交换机，交换机在得到目标mac后，查找mac表确定发送端口；如果不在同一子网下，则查找默认网关所对应mac地址，同样将其封装在数据链路层头部，并将源IP以及目标IP封装在网络层头部发送给交换机，交换机再将其发送给路由器；路由器根据数据链路层的目标IP通过查找路由表，找到对应端口将数据发送出去，同时需要查找arp表找到目标mac地址，对数据链路层头部数据更新后发送给交换机，当交换机再次接收到数据后，通过数据链路层中的目标mac地址找到对应端口发送数据。
</font>
#### http报文传输原理：在使用TCP/IP进行网络通信时，数据包会按照分层顺序与对方进行通信。发送方从应用层向下走，接受层从链路层向上走，从客户端到服务器的数据，每一帧数据的传输顺序都为：应用层-传输层-网络层-数据链路层-数据链路层-网络层-传输层-应用层。如下图所示
![](https://img-blog.csdnimg.cn/20210308122800578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center)
##### TCP/IP协议的数据封装和分用过程
* 传输层封装时，添加的报文首部要存入一个应用程序的标识符，使用<font color=#00ffff>一个16位的端口号来表示不同的应用程序，并将源端口和目标端口都存入报文首部。</font>
* 网络层封装时，IP首部会标识处理数据的协议类型，<font color=#00ffff>长度为8的数值，即协议域，同时还会包括目标IP和源IP。</font>
* 链路层封装，16位的类型域。

##### TCP协议的报文格式：TCP/IP协议栈中，<font color=#00ffff>IP协议层只关心如何使数据能够跨域本地网络边界的问题，不关心数据的传输。</font><font color=#ff0000>传输层TCP协议提供了一种面向连接的可靠的字节流服务</font>，其数据帧格式如下图：
![](https://img-blog.csdnimg.cn/20210308122904344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center)
* 源端口号：表示报文的发送端口，占16位，源端口和源IP地址组合即可标识报文的发送地址即哪台电脑的哪个应用程序。
* 目的端口号：报文的接收端口，16位。与目的IP地址结合即可标识报文的接收地址。
* 序号：TCP传输时，数据部分的每个字节都有其编号，序号占32位，发送方发送数据时，都需要标记序号。序号的语义与SYN控制标志的值相关.<font color=#00ffff>当SYN的值为1时，当前为建立阶段，此时的序号为初始序号ISN，通过算法随机生成序号。</font><font color=#ff0000>当SYN的值为0时。数据正式开始传输，第一个报文的序号为ISN+1，后续序列号的值为前一个报文的SN值+TCP报文的净荷字节数。</font><font size=5>序号的作用：发送端可以通过序号来对发送的数据进行跟踪，接收端可以通过序号识别出重复的数据包同时还可以对数据包进行排序。</font>
* 确认序号：标识了报文接收端期望接收的字节序列，如果设置了ACK控制位，那么确认序号的值标识一个准备接收的包的序列码，即下一个期望接收的包的序列码，可以防止丢包。注：只有当ACK控制位为1时，ACK序号才有效。
![](https://img-blog.csdnimg.cn/20210308123045409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70#pic_center)
* 头部长度：占用4位，表示报头首部的长度，单位是4byte。TCP头部最大有60个字节，<font color=#00ffff>无任何选项字段的TCP头部长度位20个字节，所以头部长度的值为5。</font>
* 预留六位
* 控制标志：ACK和SYN位，SYN置1表示报文为一个连接请求或接收连接请求报文。ACK置1则表示为确认序号段有效。RST：重置标志位，表示强制断开连接。
* 窗口大小：长度为16位，共2个字节。<font color=#00ffff>用来进行流量控制，单位为字节数，此值为本端期望一次接收的字节数。</font>当窗口大小的值为0时，表示可以发送窗口探测，以了解最新的窗口大小，但数据长度必须是1字节。
* 校验和：长度为2个字节，对整个TCP报文段进行校核和计算，用来接收端对数据包进行验证。
* 紧急指针

##### TCP协议可靠性的保证：
* 重传机制
* 对首部和数据进行校验
* 接收端对收到的数据进行排序，然后交给应用层
* 接收端丢弃重复的数据
* 流量控制：滑动窗口。
* 应用数据分割成TCP认为最适合发送的数据块。（协商机制）

##### 三次握手的作用：
* 防止重复历史连接的初始化，实现方法：在接收到SYN+ACK报文后，可根据序列号判断是否是历史连接，如果是，则发送RST报文给服务端，中止此次连接。
* 同步双方初始序列号。
* 防止资源浪费
##### 为什么主动断开方在TIME-WAIT状态必须等待2MSL的时间：
* 防止旧链接的数据包；TIME_WAIT状态的持续时间是2MSL，经过2MSL时间，旧链接的所有报文都在网络中消失，防止其对新连接的建立及传输过程造成影响。
* 保证两端都能够最终关闭。假设连接不可靠，那么在被动断开方发送FIN+ACK报文后，其主动方的ACK相应报文可能丢失，这时的被动断开方一直无法进入关闭状态，因此其会再次发送FIN+ACK断开相应报文，如果主动断开方在2MSL时间再次收到FIN+ACK断开相应报文，那么就再次发送ACK报文，再等待2MSL时间，保证被动断开端能够关闭。2MSL是在主动断开方发送完ACK报文后开始计时的。

### http协议与https协议的区别：
* http以明文的方式在网络中传输数据，而https在是以加密的方式在网络中传输数据
* https在TCP三次握手之后，还需要进行SSL/TLS的握手过程才能进入加密报文传输。
* http的端口号是80，https的端口号是443.
* https协议需要向CA申请数字证书来保证服务器的身份是可信的。
### TCP与UDP协议的区别
* 连接：TCP在数据传输前需要建立连接，而UDP协议不需要连接，即可传输数据。
* 服务形式：TCP只能一对一服务，而UDP支持一对一，一对多，多对多通信
* 可靠性：TCP保证数据的可靠交付，有确认应答和重传机制，无重复，不丢失，按序到达；UDP不保证可靠性，尽可能交付。
* 连接控制机制：TCP有流量控制，拥塞控制，保证传输安全性等，UDP在网络拥堵情况下不会降低发送速率。
* 首部大小：TCP首部长度在无任何选项字段的情况下是20字节，UDP首部固定8字节
* 分片方式：TCP数据大于MSS时会在TCP层间数据进行分片传输，达到目的地后同样在传输层进行合并，如果有某个片丢失则只需要重传丢失的分片即可。

### 确认应答，超时重发，序列号：接收端在接收到数据后会向发送端发送一个应答报文，如果发送端长时间没有接收到应答报文，就会重新发送上一个报文。同时为了防止重复发送导致接收端反复处理相同的数据，将报文的序列号段写入当前数据的序列号。

### 窗口控制与重发控制：确认应答不再是以段为单位，而是以一个更大的单位进行确认。其主要包括一个滑动窗口以及一片缓冲区。缓冲区存放已经发送出去的数据，当接收到应答之后将数据移除。
#### 窗口重发控制：
<font size=5> (一)应答报文丢失</font>  
$\qquad$ 某些确认应答丢失也不需要重发  
<font size=5> (二)报文段丢失</font>  
$\qquad$ 快速重传机制，当发送端重复三次收到同一应答则对对应的数据进行重发，同时在这三次应答中依然向接收端发送指定数据。

### 流量控制：接收端通过设置TCP头部窗口段的值来确定窗口的大小来保证发送端发送的数据的大小不会超过窗口的大小。

### 拥塞控制算法：
* 慢启动：定义一个拥塞窗口，将其大小设为1个数据段（MMS）发送数据，之后每接收到一次确认应答拥塞窗口的大小就加一，并将拥塞窗口的大小与指定窗口的大小比较取其最小值，发送比其还小的数据量。
* 拥塞避免：当拥塞窗口的值超过阈值之后，则进入拥塞避免阶段，拥塞窗口增长速度从指数型增长变为线性增长。
* 拥塞发生：发生拥塞（长时间没有收到ack包，触发重传）。两种重传方式：超时重传与快速重传。<font color=#00ffff>超时重传时，拥塞阈值变为原来的一般，拥塞窗口的大小变为1，再次进行慢启动重传数据。</font><font color=#ff0000>快速重传拥塞算法，当发生拥塞时，将拥塞窗口的大小设为原来的一半，再将拥塞阈值设置为拥塞窗口的大小，进入快速恢复算法。</font>
* 快速恢复算法：将拥塞窗口的值设为拥塞阈值+3，重传丢失的数据包，如果再收到重复的ACK，那么拥塞窗口的大小+1，如果收到新数据的ACK后，将cwnd设置为第一步的阈值的值，因为ACK确认收到了新的数据，说明重发的数据都已收到，恢复过程已经结束，可以恢复到之前的状态，即拥塞避免状态。

### IP基础
<font size=5>
（一）ip：TCP/IP模型中的网络层  

（二）ip的基本作用：IP寻址，路由以及IP分包与组包。  

$\qquad$ 1.IP地址：属于网络层地址，用于在网络种表示出主机的通信目标地址。
$\qquad$ 2.路由控制：将分组数据发送到最终目标地址的功能。  
* $\qquad$ $\qquad$ 基础概念：hop(跳)：指网络中的一个区间，在数据链路层的表现即从<font color=#00ffff>从源MAC地址到目标MAC地址之间传输的区间，中间无其它主机或路由器。</font>  
* $\qquad$ $\qquad$ 路由控制表：该表记录IP地址与端口的映射关系。  

$\qquad$ 3.IP分包与组包：由于不同数据链路运载数据的能力不同，存在
<font color=#00ffff>
最大传输单位的限制。
</font>而IP的上一层可能要求传输较大的数据量，因此需要对较大的IP包进行拆分，分为较小的IP包，也就是<font color=#00ffff>
分包。
</font>
而当被分片的包到达目标地址后会被再重新组合起来被传递给上层，
<font color=#00ffff>
被称为组包。
</font>  
$\qquad$ 4.IP属于面向无连接型：即在发包前不需要建立与对端目标的连接，原因如下：
* $\qquad$ $\qquad$ 简化：对连接的管理本身就是一个繁琐的事情
* $\qquad$ $\qquad$ 快速：每次建立连接会降低处理速度。
<font color=#00ffff>
需要有连接时可以委托上一层提供此服务
</font>  

（三）IP地址的基础知识：IP地址用来识别主机和路由器，为了保证正常通信，需要为每个设备分配正确的IP地址。  
$\qquad$ 1.IP地址的定义：IP地址（IPv4地址）由32位正整数来表示。因此IPv4的IP总量为43亿台。  
$\qquad$ $\qquad$ 1.2：基础概念：网卡，主机，路由器，IP；
<font color=#00ffff>
每个网卡需要分配一个IP地址，一台主机至少需要分配一个IP地址，一个路由器可以分配两个以上的IP地址
</font>  

$\qquad$ 2.主机标识与网络标识：主机标识用来确定相同网络段内的唯一主机，网络标识则用来确定网络段。确定主机标识与网络标识的两种方式:
<font color=#00ffff>
分类进行区别，使用子网掩码进行区别。
</font>  

$\qquad$ $\qquad$ 2.1.IP地址的分类：分为A类，B类，C类，D类。
<font color=#00ffff>
通过IP地址种第1位到第4位来进行区分。
</font>
<font color=#ff0000>
注意：在分配IP主机地址时，其主机标识不可全为0或全为1。全为0的IP地址只有在对应的网络地址或IP地址不可获知时使用，而全为1的主机地址通常作为广播地址。因此在分配地址时需要减去这两个主机地址。并且D类地址有一种特殊的用途，即作为多播地址。
</font>  

$\qquad$ $\qquad$ 2.2.广播地址的分类：本地广播，直接广播。
<font color=#00ffff>
本地广播对当前网络内的所有主机进行广播；直接广播是对目标网络内的所有主机进行广播。
</font>  

$\qquad$ $\qquad$ 2.3.IP多播与地址。多播指对
<font color=#00ffff>
指定组内的所有主机
</font>
进行广播,并且可以穿过路由器。其所使用地址为D类地址。
<font color=#00ffff>
此外对于多播，所有的主机都必须属于224.0.01的组，所有的路由器都属于224.0.0.2的组。
</font>  
$\qquad$ 3.子网掩码：由于传统的分类方法会造成资源的浪费，因此使用子网掩码的方式来对网络进行更细致的划分。  

$\qquad$ $\qquad$ 3.1.子网掩码：IP首位开始连续为1的一串32位字符。  
$\qquad$ 4.全局地址与私有地址：由于互联网的迅速普及，IP地址不足的问题日趋显著，因此出现了一种新技术，不要求位每台主机都分配唯一的IP地址，
<font color=#00ffff>
只在必要的时候分配唯一的地址（以时间换空间）。
</font>  

$\qquad$ $\qquad$ 4.1 私有IP地址：
<font color=#00ffff>
A类（10/8），B类（172.16/12），C类（192.168/16）。
</font>  
（四）路由控制：当每台主机的IP地址都被正确分配后，
<font color=#00ffff>
就需要根据IP地址找到指定的对端目标地址,
</font>
这需要路由控制表来实现，
<font color=#00ffff>
而路由控制表主要通过动态路由控制来刷新
</font>
</font>

# 内存泄漏的检查方法
1：借助工具进行检测，如Valgrind，GDB，DMalloc等工具
2：手动检测方法：观察程序中的new，delete或malloc以及free是否成对出现。
# 什么时候适合使用单线程：
1：程序为顺序执行，不需要多并发
2：如果是计算密集型的程序，单线程的执行效率更高。
